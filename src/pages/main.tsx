import { useEffect, useState } from 'react'
import Display from '~/components/Display'
import ElementsLine from '~/components/ElementsLine'
import Head from "next/head";
import Elements from '../server/elements.json'

//https://littlealchemy.com
//http://localhost:3000/main
//https://cloud.mongodb.com/v2/647b96642faffe4cba6843ba#/clusters/connect?clusterId=littleAlchemi
//https://www.pinterest.com/pin/769763761333151110/
//https://create.t3.gg/en/usage/first-steps
//https://github.com/helmturner/t3-mongo-template/blob/main/src/server/db.ts

//https://little-alchemy.fandom.com/wiki/Elements_(Little_Alchemy_1)

//https://www.npmjs.com/package/react-draggable

type Combination = {
  [key: string]: string[]
}

const allCombinations: Combination = {
  "Dust": ["Earth + Air", "Air + Earth"]
  ,"Energy": ["Air + Fire", "Fire + Air"]
  ,"Lava": ["Earth + Fire", "Fire + Earth"]
  ,"Mud": ["Earth + Water", "Water + Earth"]
  ,"Pressure": ["Earth + Earth", "Air + Air"]
  ,"Rain": ["Water + Air", "Air + Water"]
}

type Element = {
  name: string;
  img: string;
  unlocked: boolean
}

type Image = {
  src: string;
  alt: string;
  position: {
    x: number,
    y: number
  }
}

function main() {
  const [images, setImages] = useState<Image[]>([]);

  useEffect(() => {
    const areOverlapping = (rect1: DOMRect, rect2: DOMRect): boolean => {
      return (
        rect1.left < rect2.right &&
        rect1.right > rect2.left &&
        rect1.top < rect2.bottom &&
        rect1.bottom > rect2.top
      );
    };

    const checkForOverlaps = () => {
      // const imageElements = document.querySelectorAll('img');
      const imageElements = document.querySelectorAll('img');

      for (let i = 0; i < imageElements.length; i++) {
        const rect1 = imageElements[i]?.getBoundingClientRect();
        const image1 = images[i]

        for (let j = i + 1; j < imageElements.length; j++) {
          const rect2 = imageElements[j]?.getBoundingClientRect();
          const image2 = images[j]

          if ((rect1 !== undefined && rect2 !== undefined) && (image1 !== undefined && image2 !== undefined)) {
            if (areOverlapping(rect1, rect2)) {
              console.log(`Images-${imageElements[i]?.alt} ${i + 1} and Images-${imageElements[j]?.alt} ${j + 1} are overlapping.`);
              const combination = `${imageElements[i]?.alt} + ${imageElements[j]?.alt}`

              let foundKey: string | undefined;

              Object.entries(allCombinations).forEach(([key, value]) => {
                if (Array.isArray(value) && value.includes(combination)) {
                  foundKey = key;
                }
              });

              const lastPosition = image1.position

              if (foundKey) {
                const created: Element | undefined = Elements.filter(current => current.name === foundKey)[0]
                const newArray = [...images]

                newArray.splice(i, 1)
                newArray.splice(j - 1, 1)


                if ((created !== undefined) && (images[images.length - 1]?.alt !== foundKey)) {
                  newArray.push({
                    alt: created.name,
                    src: created.img,
                    position: lastPosition
                    // position: { x: 0, y: 0 }
                  })

                  setImages(newArray)
                }
              }
            }
          }
        }
      }
    };

    checkForOverlaps();
  }, [images])

  const handleClick = (elementSended: Element) => {
    const newImage: Image = {
      src: elementSended.img,
      alt: elementSended.name,
      position: { x: 0, y: 0 }
    };
    setImages([...images, newImage]);
  };

  const deleteImage = (imageSended: Image, indexSended: number) => {
    setImages(prevImages => prevImages.filter((image, index) =>
      (image !== imageSended) && (index !== indexSended)
    ));
    // setImages(prevImages => prevImages.splice(indexSended, 0));
  }

  const handleImageLoad = (event: React.SyntheticEvent<HTMLImageElement>) => {
    const imageElement = event.target as HTMLImageElement;
    const { x, y } = imageElement.getBoundingClientRect();

    setImages(prevImages => prevImages.map(currentImage => {
      return {
        ...currentImage,
        position: { x, y }
      }
    }));
  };

  console.log(images)

  return (
    <>
      <Head>
        <title>Little Alchemy - Clone</title>
        <meta name="description" content="Generated by create-t3-app" />
        <link rel="icon" href="https://littlealchemy.com/img/little-alchemy-1024-logo.png" />
      </Head>

      <div data-theme="light" className='min-h-screen'>
        <div className='flex flex-row h-screen max-h-screen overflow-hidden'>
          <Display
            images={images}
            deleteImage={deleteImage}
            handleImageLoad={handleImageLoad}
          />
          <ElementsLine
            handleClick={handleClick}
          />
        </div>
      </div>
    </>

  )
}

export default main